//    Copyright (C) Mike Rieker, Beverly, MA USA
//    www.outerworldapps.com
//
//    This program is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; version 2 of the License.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    EXPECT it to FAIL when someone's HeALTh or PROpeRTy is at RISk.
//
//    You should have received a copy of the GNU General Public License
//    along with this program; if not, write to the Free Software
//    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//    http://www.gnu.org/licenses/gpl-2.0.html

/**
 * Built-in RaspberryPi module.
 * It provides connector and interface circuits.
 */

import java.io.IOException;
import java.io.PrintStream;

public class RasPiModule extends Module {
    private double moduleleftx;
    private double moduletopy;
    private int nbits;
    private String instvarsuf;

    private Network clkcpunet;      // cpu side of clock level converter
    private Network irqcpunet;      // cpu side of irq level converter
    private Network rescpunet;      // cpu side of reset level converter
    private Network v33net;         // 3.3V coming from raspi for level converters
    private Network vccnet;         // 5.0V power supply
    private Network _mrdcpunet;     // cpu side of mem read level converter
    private Network _mwtcpunet;     // cpu side of mem write level converter
    private Network ioincpunet;     // cpu side of ioin level converter
    private Network _iakcpunet;     // cpu side of int ack level converter
    private Network _dfrmcpunet;    // cpu side of dfrm level converter
    private Network _jumpcpunet;    // cpu side of jump level converter
    private Network _mdlcpunet;     // cpu side of link being sent to raspi level converter
    private Network mqlcpunet;      // cpu side of link being read from raspi level converter
    private Network ioscpunet;      // cpu side of io skip being read from raspi level converter
    private Network[] _mdcpunets;   // cpu side of data being sent to raspi level converter
    private Network[] mqcpunets;    // cpu side of data being read from raspi level converter

    private OpndLhs clk;            // clock output
    private OpndLhs irq;            // int req output
    private OpndLhs res;            // reset output
    private OpndLhs mq;             // mem data output (12 bits)
    private OpndLhs mql;            // link data output
    private OpndLhs ios;            // io skip output

    private OpndLhs _md;            // mem data input (12 bits)
    private OpndLhs _mdl;           // link data input
    private OpndLhs _mrd;           // read mem input
    private OpndLhs _mwt;           // write mem input
    private OpndLhs _iak;           // intrrupt acknowledge
    private OpndLhs _dfrm;          // data frame input
    private OpndLhs _jump;          // jump instr input
    private OpndLhs ioin;           // io instr input

    public RasPiModule (String instvarsuf)
    {
        this (instvarsuf, 12);
    }

    public RasPiModule (String instvarsuf, int nbits)
    {
        name = "RasPi" + instvarsuf;
        this.instvarsuf = instvarsuf;
        this.nbits = nbits;

        // signals generated by raspberry pi going to processor
        clk = new CLKOutput ("CLK" + instvarsuf, 0);    // clock (50% duty, low-to-high starts a cycle)
        irq = new IRQOutput ("IRQ" + instvarsuf, 1);    // interrupt request
        res = new RESOutput ("RES" + instvarsuf, 2);    // asynchronous reset
         mq = new  MQOutput ( "MQ" + instvarsuf, 3);    // memory & i/o read data
        mql = new MQLOutput ("MQL" + instvarsuf, 4);    // link updated by i/o instruction
        ios = new IOSOutput ("IOS" + instvarsuf, 5);    // i/o instruction saying to skip next instruction

        // signals generated by processor going to raspberry pi
        if (instvarsuf.equals ("")) {
              _md = new IParam (  "_MD",  6);           // memory address and memory and i/o data
             _mdl = new IParam ( "_MDL",  7);           // link register
             _mrd = new IParam ( "_MRD",  8);           // this cycle has memory address to be read
             _mwt = new IParam ( "_MWT",  9);           // this cycle has memory address to be written
             _iak = new IParam ( "_IAK", 10);           // this cycle is acknowledging interrupt
            _dfrm = new IParam ("_DFRM", 11);           // this memory cycle uses the data frame
            _jump = new IParam ("_JUMP", 12);           // this cycle is part of a JMP/JMS instruction
             ioin = new IParam ( "IOIN", 13);           // this cycle is an i/o instruction with opcode on _MD
        } else {
              _md = new OpndLhs (  "_MD" + instvarsuf);
             _mdl = new OpndLhs ( "_MDL" + instvarsuf);
             _mrd = new OpndLhs ( "_MRD" + instvarsuf);
             _mwt = new OpndLhs ( "_MWT" + instvarsuf);
             _iak = new OpndLhs ( "_IAK" + instvarsuf);
            _dfrm = new OpndLhs ("_DFRM" + instvarsuf);
            _jump = new OpndLhs ("_JUMP" + instvarsuf);
             ioin = new OpndLhs ( "IOIN" + instvarsuf);
        }

        mq.hidim = _md.hidim = nbits - 1;

        params = new OpndLhs[] { clk, irq, res, mq, mql, ios, _md, _mdl, _mrd, _mwt, _iak, _dfrm, _jump, ioin };

        for (OpndLhs param : params) {
            variables.put (param.name, param);
        }
    }

    // this gets the test flag token after the module name and before the (
    // eg, inst : RasPi test2 ( ... );
    //                   ^ token is here
    //                        ^ return token here
    @Override
    public Token getInstConfig (Token token, String instvarsuf, Object[] instconfig_r)
            throws Exception
    {
        int nbits = 12;
        while (! token.isDel (Token.DEL.OPRN)) {
            if ("test2".equals (token.getSym ())) {
                nbits = 2;
                token = token.next;
                continue;
            }
            throw new Exception ("bad raspi config " + token.toString ());
        }
        instconfig_r[0] = nbits;
        return token;
    }

    // make a new RasPi module instance with wires for parameters
    // the parameter names are suffixed by instvarsuf
    @Override
    public OpndLhs[] getInstParams (UserModule target, String instvarsuf, Object instconfig)
            throws Exception
    {
        RasPiModule raspiinst = new RasPiModule (instvarsuf, (Integer) instconfig);

        // make connector's pin variables available to target module
        target.variables.putAll (raspiinst.variables);

        // add output pins to list of top-level things that need to have circuits generated
        // this is how we guarantee circuits that drive these pins will be generated
        target.generators.add (  _md);
        target.generators.add ( _mdl);
        target.generators.add ( _mrd);
        target.generators.add ( _mwt);
        target.generators.add ( _iak);
        target.generators.add (_dfrm);
        target.generators.add (_jump);
        target.generators.add ( ioin);

        return raspiinst.params;
    }

    // the internal circuitry that writes to the output wires

    private class CLKOutput extends OParam {
        public CLKOutput (String name, int index)
        {
            super (name, index);
        }

        public RasPiModule getRasPi ()
        {
            return RasPiModule.this;
        }

        @Override
        public String checkWriters ()
        {
            return null;
        }

        @Override  // OpndLhs
        public boolean forceable ()
        {
            return true;
        }

        //// GENERATOR ////

        @Override
        public Network generate (GenCtx genctx, int rbit)
        {
            assert rbit == 0;
            getCircuit (genctx);
            return clkcpunet;
        }

        @Override
        public void printProp (PropPrinter pp, int rbit)
        {
            pp.println ("RasPi", this, rbit);
        }

        //// SIMULATOR ////

        @Override
        protected int busWidthWork ()
        {
            return 1;
        }

        @Override
        protected void stepSimWork (int t)
                throws HaltedException
        {
            stepSimulator (t);
        }
    }

    private class IRQOutput extends OParam {
        public IRQOutput (String name, int index)
        {
            super (name, index);
        }

        @Override
        public String checkWriters ()
        {
            return null;
        }

        @Override  // OpndLhs
        public boolean forceable ()
        {
            return true;
        }

        //// GENERATOR ////

        @Override
        public Network generate (GenCtx genctx, int rbit)
        {
            assert rbit == 0;
            getCircuit (genctx);
            return irqcpunet;
        }

        @Override
        public void printProp (PropPrinter pp, int rbit)
        {
            pp.println ("RasPi", this, rbit);
        }

        //// SIMULATOR ////

        @Override
        protected int busWidthWork ()
        {
            return 1;
        }

        @Override
        protected void stepSimWork (int t)
                throws HaltedException
        {
            stepSimulator (t);
        }
    }

    private class RESOutput extends OParam {
        public RESOutput (String name, int index)
        {
            super (name, index);
        }

        @Override
        public String checkWriters ()
        {
            return null;
        }

        @Override  // OpndLhs
        public boolean forceable ()
        {
            return true;
        }

        //// GENERATOR ////

        @Override
        public Network generate (GenCtx genctx, int rbit)
        {
            assert rbit == 0;
            getCircuit (genctx);
            return rescpunet;
        }

        @Override
        public void printProp (PropPrinter pp, int rbit)
        {
            pp.println ("RasPi", this, rbit);
        }

        //// SIMULATOR ////

        @Override
        protected int busWidthWork ()
        {
            return 1;
        }

        @Override
        protected void stepSimWork (int t)
                throws HaltedException
        {
            stepSimulator (t);
        }
    }

    private class MQOutput extends OParam {
        public MQOutput (String name, int index)
        {
            super (name, index);
        }

        @Override
        public String checkWriters ()
        {
            return null;
        }

        @Override  // OpndLhs
        public boolean forceable ()
        {
            return true;
        }

        //// GENERATOR ////

        @Override
        public Network generate (GenCtx genctx, int rbit)
        {
            getCircuit (genctx);
            return mqcpunets[rbit];
        }

        @Override
        public void printProp (PropPrinter pp, int rbit)
        {
            pp.println ("RasPi", this, rbit);
        }

        //// SIMULATOR ////

        @Override
        protected int busWidthWork ()
        {
            return nbits;
        }

        @Override
        protected void stepSimWork (int t)
                throws HaltedException
        {
            stepSimulator (t);
        }
    }

    private class MQLOutput extends OParam {
        public MQLOutput (String name, int index)
        {
            super (name, index);
        }

        @Override
        public String checkWriters ()
        {
            return null;
        }

        @Override  // OpndLhs
        public boolean forceable ()
        {
            return true;
        }

        //// GENERATOR ////

        @Override
        public Network generate (GenCtx genctx, int rbit)
        {
            getCircuit (genctx);
            return mqlcpunet;
        }

        @Override
        public void printProp (PropPrinter pp, int rbit)
        {
            pp.println ("RasPi", this, rbit);
        }

        //// SIMULATOR ////

        @Override
        protected int busWidthWork ()
        {
            return nbits;
        }

        @Override
        protected void stepSimWork (int t)
                throws HaltedException
        {
            stepSimulator (t);
        }
    }

    private class IOSOutput extends OParam {
        public IOSOutput (String name, int index)
        {
            super (name, index);
        }

        @Override
        public String checkWriters ()
        {
            return null;
        }

        @Override  // OpndLhs
        public boolean forceable ()
        {
            return true;
        }

        //// GENERATOR ////

        @Override
        public Network generate (GenCtx genctx, int rbit)
        {
            getCircuit (genctx);
            return ioscpunet;
        }

        @Override
        public void printProp (PropPrinter pp, int rbit)
        {
            pp.println ("RasPi", this, rbit);
        }

        //// SIMULATOR ////

        @Override
        protected int busWidthWork ()
        {
            return nbits;
        }

        @Override
        protected void stepSimWork (int t)
                throws HaltedException
        {
            stepSimulator (t);
        }
    }

    // generate circuitry, ie, connector and level converters, for the raspberry pi
    // connect networks to its pins
    private void getCircuit (GenCtx genctx)
    {
        if (mqcpunets == null) {

            // connectors and holes always go in lower right corner of board
            moduleleftx = genctx.boardwidth - NetGen.CORNER10THS - 25;
            moduletopy  = genctx.boardheight - 25;

            // set up networks (circuit board traces) that the CPU uses to read 12-bit data from the RasPi
            mqcpunets = new Network[nbits];
            for (int i = 0; i < nbits; i ++) {
                mqcpunets[i] = new Network (genctx, String.format ("mq%2d.%s", i, name));
            }

            // set up networks (circuit board traces) that the CPU uses to get these other signals from the RasPi
            NetClass v33class = genctx.netclasses.get ("v33wires");
            v33net    = new Network (genctx, "v33." + name, v33class);      // raspi provides 3.3V for pullup resistors
            clkcpunet = new Network (genctx, "clk." + name);                // raspi writes clock signal to this pin
            rescpunet = new Network (genctx, "res." + name);                // raspi writes reset signal to this pin
            irqcpunet = new Network (genctx, "irq." + name);                // raspi writes int req signal to this pin
            ioscpunet = new Network (genctx, "ios." + name);                // raspi writes io skip signal to this pin
            mqlcpunet = new Network (genctx, "mql." + name);                // raspi writes link signal to this pin

            // get the networks that the CPU sends 12-bit address and data to the RasPi on
            // - generate those circuits if not already generated
            _mdcpunets = new Network[nbits];
            for (int i = 0; i < nbits; i ++) {
                genctx.addPropRoot (_md, i);
                _mdcpunets[i] = _md.generate (genctx, i);
            }

            // likewise for other signals coming from the CPU going to the RasPi
            genctx.addPropRoot ( _mdl, 0);
            genctx.addPropRoot ( _mrd, 0);
            genctx.addPropRoot ( _mwt, 0);
            genctx.addPropRoot ( _iak, 0);
            genctx.addPropRoot (_dfrm, 0);
            genctx.addPropRoot (_jump, 0);
            genctx.addPropRoot ( ioin, 0);
            _mdlcpunet  =  _mdl.generate (genctx, 0);    // generate tube circuitry that drives the MDL signal
            _mrdcpunet  =  _mrd.generate (genctx, 0);    // generate tube circuitry that drives the MRD signal
            _mwtcpunet  =  _mwt.generate (genctx, 0);    // generate tube circuitry that drives the MWT signal
            _iakcpunet  =  _iak.generate (genctx, 0);    // generate tube circuitry that drives the IAK signal
            _dfrmcpunet = _dfrm.generate (genctx, 0);    // generate tube circuitry that drives the DFRM signal
            _jumpcpunet = _jump.generate (genctx, 0);    // generate tube circuitry that drives the JUMP signal
            ioincpunet  =  ioin.generate (genctx, 0);    // generate tube circuitry that drives the IOIN signal

            // make cells that drive uni-directional PI inputs without putting 5V on the RasPi
            // the raspi provides 3.3V for the pullups
            PiInCell  _mrdcell = new PiInCell (genctx,  "_mrd." + name, _mrdcpunet,  new Network (genctx,  "__mrd3V." + name));
            PiInCell  _mwtcell = new PiInCell (genctx,  "_mwt." + name, _mwtcpunet,  new Network (genctx,  "__mwt3V." + name));
            PiInCell  _iakcell = new PiInCell (genctx,  "_iak." + name, _iakcpunet,  new Network (genctx,  "__iak3V." + name));
            PiInCell _dfrmcell = new PiInCell (genctx, "_dfrm." + name, _dfrmcpunet, new Network (genctx, "__dfrm3V." + name));
            PiInCell _jumpcell = new PiInCell (genctx, "_jump." + name, _jumpcpunet, new Network (genctx, "__jump3V." + name));
            PiInCell  ioincell = new PiInCell (genctx,  "ioin." + name, ioincpunet,  new Network (genctx,  "_ioin3V." + name));

            // make cells that read uni-directional PI outputs without putting 5V on the RasPi
            vccnet = genctx.nets.get ("VCC");
            PiOutCell clkcell = new ClockCell (genctx, "clk." + name, clkcpunet, new Network (genctx, "_clk3V." + name));
            PiOutCell rescell = new PiOutCell (genctx, "res." + name, rescpunet, new Network (genctx, "_res3V." + name), vccnet);
            PiOutCell irqcell = new PiOutCell (genctx, "irq." + name, irqcpunet, new Network (genctx, "_irq3V." + name), vccnet);
            PiOutCell ioscell = new PiOutCell (genctx, "ios." + name, ioscpunet, new Network (genctx, "_ios3V." + name), vccnet);
            Network denpinet = new Network (genctx, "denab3V." + name);
            PiOutCell[] _denacells = new PiOutCell[] {
                new PiOutCell (genctx, "_dena0." + name, new Network (genctx, "_dena0." + name), denpinet, v33net),
                new PiOutCell (genctx, "_dena1." + name, new Network (genctx, "_dena1." + name), denpinet, v33net)
            };
            Network qenpinet = new Network (genctx, "qenab3V." + name);
            PiOutCell[] _qenacells = new PiOutCell[] {
                new PiOutCell (genctx, "_qena0." + name, new Network (genctx, "_qena0." + name), qenpinet, v33net),
                new PiOutCell (genctx, "_qena1." + name, new Network (genctx, "_qena1." + name), qenpinet, v33net)
            };

            // make a set of 3.3V bi-directional cells for the data and link networks
            // there aren't enough GPIO pins on the RasPi for separate mdbus and mqbus
            // ...so it has to be multiplexed with the wdata signal coming from the Pi
            PiBiCell   lnkcell = new PiBiCell (genctx, "lnk." + name, _denacells[1].cpunet, _qenacells[1].cpunet, _mdlcpunet, mqlcpunet);
            PiBiCell[] bdcells = new PiBiCell[nbits];
            for (int i = 0; i < nbits; i ++) {
                bdcells[i] = new PiBiCell (genctx, String.format ("m%02d.%s", i, name),
                                _denacells[i*2/nbits].cpunet, _qenacells[i*2/nbits].cpunet, _mdcpunets[i], mqcpunets[i]);
            }

            // make a connector object and wire up all the pins
            Comp.Conn connector = new Comp.Conn (genctx, genctx.conncol, name, 20, 2);
            connector.orien = Comp.Conn.Orien.OVER;

            // the PI doc has pins numbered:
            //            1  2
            //    B       3  4
            //    U       5  6
            //    L       7  8
            //    K       9 10
            //    O      11 12
            //    F      13 14
            //    B      15 16
            //    O      17 18
            //    A      19 20
            //    R      21 22
            //    D      23 24
            //           25 26
            //    F      27 28
            //    A      29 30
            //    C      31 32
            //    E      33 34
            //    U      35 36
            //    P      37 38
            //           39 40
            // [ETHERNET  USB]

            clkcell._pinet.addConn (connector,  "3");   //  GPIO[02] =  3 = clock
            rescell._pinet.addConn (connector,  "5");   //  GPIO[03] =  5 = reset

            //  GPIO[15:04] = data[11:00]   10, 8, 33,32, 23,19,21,24, 26,31,29, 7
            int[] mpins = new int[]       { 10, 8, 33,32, 23,19,21,24, 26,31,29, 7 };
            for (int i = 0; i < nbits; i ++) {
                bdcells[i]._pinet.addConn (connector, Integer.toString (mpins[11-i]));
            }

              lnkcell._pinet.addConn (connector, "36"); //  GPIO[16] = 36 = link
              ioscell._pinet.addConn (connector, "11"); //  GPIO[17] = 11 = ioskip
                                                        //  GPIO[18] = 12 = n/c
                    qenpinet.addConn (connector, "35"); //  GPIO[19] = 35 = pi-to-cpu data enable
              irqcell._pinet.addConn (connector, "38"); //  GPIO[20] = 38 = int request
                    denpinet.addConn (connector, "40"); //  GPIO[21] = 40 = cpu-to-pi data enable
            _jumpcell._pinet.addConn (connector, "15"); //  GPIO[22] = 15 = jump
             ioincell._pinet.addConn (connector, "16"); //  GPIO[23] = 16 = ioinstr
            _dfrmcell._pinet.addConn (connector, "18"); //  GPIO[24] = 18 = dfrm
             _mrdcell._pinet.addConn (connector, "22"); //  GPIO[25] = 22 = read
             _mwtcell._pinet.addConn (connector, "37"); //  GPIO[26] = 37 = write
             _iakcell._pinet.addConn (connector, "13"); //  GPIO[27] = 13 = int acknowledge

            //  pullup power from raspi (+3.3V)  1,17
            v33net.addConn (connector, "1");

            //  power supplied to raspi (+5V)  2,4
            vccnet.addConn (connector, "2");
            vccnet.addConn (connector, "4");

            //  ground   6, 9,14,20,25,30,34,39
            Network gndnet = genctx.nets.get ("GND");
            gndnet.addConn (connector,  "6");
            gndnet.addConn (connector,  "9");
            gndnet.addConn (connector, "14");
            gndnet.addConn (connector, "20");
            gndnet.addConn (connector, "25");
            gndnet.addConn (connector, "30");
            gndnet.addConn (connector, "34");
            gndnet.addConn (connector, "39");

            // fill in unconnected pins so we get holes drilled on board
            for (int p = 1; p <= 40; p ++) {
                String s = Integer.toString (p);
                if (connector.getPinNetwork (s) == null) {
                    Network n = new Network (genctx, s + "-nc." + name);
                    n.addConn (connector, s);
                }
            }

            // position on circuit board
            connector.setPosXY (moduleleftx, moduletopy + 2);

            // place 6 mounting holes
            double holexs[] = { 0.5, 9.5, 20.0 };
            for (int cy = 0; cy < 2; cy ++) {
                for (int cx = 0; cx < 3; cx ++) {
                    Comp.Hole hole = new Comp.Hole (genctx, null, cx + "." + cy + "." + name);
                    hole.setPosXY (moduleleftx + holexs[cx], moduletopy + cy * 23);
                }
            }
        }
    }

    //// SIMULATOR ////

    private void stepSimulator (int t)
            throws HaltedException
    {
        // test script should use force commands to set the outputs (such as CLK,IRQ,MQ,...)
        // ...and use examine commands to verify the inputs (such as MRD,JUMP,MD,...)
    }

    // process 'raspi' sim script command
    public static String simCmd (Module module, String instname, String[] args, int simtime)
            throws Exception
    {
        throw new Exception ("raspi command not implemented");
    }

    /**
     * Cell for signal coming from CPU to RasPi input
     *
                                           (V33)
                                             |
                                             _
                                           rcoll
                                             _
                                             |
                                          (_pinet)
                                             |
                                            /
       (cpunet)----[inres]----(basenet)----|
                                  |         \
                                  _          |
                                zener      (GND)
                                  _
                                  |
                                (GND)
     */
    private class PiInCell extends Placeable {
        private Comp.ByCap bycap;
        private Comp.Resis inres;
        private Comp.Trans trans;
        private Comp.Diode zener;
        private Comp.Resis rcoll;
        private Network cpunet;
        private Network _pinet;
        private String name;

        public PiInCell (GenCtx genctx, String name, Network cpunet, Network _pinet)
        {
            this.name   = name;
            this.cpunet = cpunet;
            this._pinet = _pinet;

            inres = new Comp.Resis (genctx, null, "R1." + name, "10K",    true,  true);
            trans = new Comp.Trans (genctx, null, "Q."  + name, "2N7000");
            bycap = new Comp.ByCap (genctx, null, "BC." + name);
            zener = new Comp.Diode (genctx, null, "D1." + name, "1N5239", true,  true); // 9.1V, anything over 5V is good
            rcoll = new Comp.Resis (genctx, null, "R2." + name, "1.8K",   true,  true);

            Network basenet = new Network (genctx, "B." + name);
            Network gndnet  = genctx.nets.get ("GND");

            cpunet.addConn  (inres, Comp.Resis.PIN_A, 1);

            basenet.preWire (trans, Comp.Trans.PIN_B, inres, Comp.Resis.PIN_C);
            basenet.preWire (zener, Comp.Diode.PIN_C, inres, Comp.Resis.PIN_C);
            _pinet.preWire  (trans, Comp.Trans.PIN_C, rcoll, Comp.Resis.PIN_C);

            v33net.addConn  (rcoll, Comp.Resis.PIN_A);
            v33net.addConn  (bycap, Comp.ByCap.PIN_Y);
            gndnet.addConn  (trans, Comp.Trans.PIN_E);
            gndnet.addConn  (bycap, Comp.ByCap.PIN_Z);
            gndnet.addConn  (zener, Comp.Resis.PIN_A);

            genctx.addPlaceable (this);
        }

        @Override  // Placeable
        public String getName () { return name; }

        @Override  // Placeable
        public void flipIt () { }

        @Override  // Placeable
        public int getHeight () { return 6; }

        @Override  // Placeable
        public int getWidth  () { return 8; }

        @Override  // Placeable
        public double getPosX () { return zener.getPosX (); }

        @Override  // Placeable
        public double getPosY () { return zener.getPosY (); }

        @Override  // Placeable
        public void setPosXY (double leftx, double topy)
        {
            zener.setPosXY (leftx + 0.0, topy + 0.0);
            inres.setPosXY (leftx + 0.0, topy + 3.0);
            rcoll.setPosXY (leftx + 3.0, topy + 0.0);
            trans.setPosXY (leftx + 4.0, topy + 2.0);
            bycap.setPosXY (leftx + 4.0, topy + 2.0);
        }

        @Override  // Placeable
        public Network[] getExtNets ()
        {
            return new Network[] { cpunet, _pinet };
        }
    }

    /**
     * Cell for signal coming from RasPi output to CPU
     * Just a resistor from RasPi to transistor base without diodes or pullup
     * Cuz we don't want pullup putting 5V into RasPi and no diodes cuz the
     * Transistor is only driven by one input line
     *
                                  (VPP)  (3.3 or 5.0V)
                                    |
                                    _
                                   rout
                                    _
                                    |
                                 (cpunet)
                                    |
                                   /
        (_pinet)-------[rin]--+---|
                              |    \
                              _     |
                            rbas  (GND)
                              _
                              |
                            (GND)
     */
    private class PiOutCell extends Placeable {
        public Network cpunet;
        public Network _pinet;

        private String name;
        private Comp.Resis rin;
        private Comp.Trans trn;
        private Comp.ByCap byc;
        private Comp.Resis rout;
        private Comp.Resis rbas;

        public PiOutCell (GenCtx genctx, String name, Network cpunet, Network _pinet, Network vppnet)
        {
            this.name   = name;
            this.cpunet = cpunet;
            this._pinet = _pinet;

            rin  = new Comp.Resis (genctx, null, "R1." + name, "2.2K", false, true);
            trn  = new Comp.Trans (genctx, null, "Q."  + name, "2N3904");
            byc  = new Comp.ByCap (genctx, null, "BC." + name);
            rout = new Comp.Resis (genctx, null, "R2." + name, "1.8K", false, true);
            rbas = new Comp.Resis (genctx, null, "R3." + name, "1.0K", true, true);

            _pinet.addConn (rin, Comp.Resis.PIN_C);

            Network brnet = new Network (genctx, "B." + name);
            brnet.preWire  (trn, Comp.Trans.PIN_B, rin,  Comp.Resis.PIN_A);
            brnet.preWire  (rin, Comp.Resis.PIN_A, rbas, Comp.Resis.PIN_C);

            cpunet.preWire (trn, Comp.Trans.PIN_C, rout, Comp.Resis.PIN_A);

            Network gndnet = genctx.nets.get ("GND");

            gndnet.addConn (trn,  Comp.Trans.PIN_E);
            gndnet.addConn (byc,  Comp.ByCap.PIN_Z);
            gndnet.addConn (rbas, Comp.Resis.PIN_A);
            vppnet.addConn (byc,  Comp.ByCap.PIN_Y);
            vppnet.addConn (rout, Comp.Resis.PIN_C);

            genctx.addPlaceable (this);
        }

        @Override  // Placeable
        public String getName () { return name; }

        @Override  // Placeable
        public void flipIt () { }

        @Override  // Placeable
        public int getHeight () { return 6; }

        @Override  // Placeable
        public int getWidth  () { return 8; }

        @Override  // Placeable
        public double getPosX () { return rbas.getPosX (); }

        @Override  // Placeable
        public double getPosY () { return rbas.getPosY (); }

        @Override  // Placeable
        public void setPosXY (double leftx, double topy)
        {
            rbas.setPosXY (leftx + 0.0, topy + 0.0);
             rin.setPosXY (leftx + 0.0, topy + 3.0);
            rout.setPosXY (leftx + 3.0, topy + 0.0);
             trn.setPosXY (leftx + 4.0, topy + 2.0);
             byc.setPosXY (leftx + 4.0, topy + 2.0);
        }

        @Override  // Placeable
        public Network[] getExtNets ()
        {
            return new Network[] { cpunet, _pinet };
        }
    }

    // make out cell for clock line special just so we can output copper exclusion zones
    // ... so an hole for heatsink can be drilled in board
    private class ClockCell extends PiOutCell implements PreDrawable {
        public ClockCell (GenCtx genctx, String name, Network cpunet, Network _pinet)
        {
            super (genctx, name, cpunet, _pinet, vccnet);
            genctx.predrawables.add (this);
        }

        @Override  // PreDrawable
        public void preDraw (PrintStream ps)
        {
            String leftmm = String.format ("%4.2f", (moduleleftx +  4.5) * 2.54);
            String ritemm = String.format ("%4.2f", (moduleleftx + 19.0) * 2.54);
            String topmm  = String.format ("%4.2f", (moduletopy  +  3.0) * 2.54);
            String botmm  = String.format ("%4.2f", (moduletopy  + 22.0) * 2.54);
            String[] layers = new String[] { "F.Cu", "In1.Cu", "In2.Cu", "B.Cu" };
            for (String layer : layers) {
                String tstamp = String.format ("%08X", layer.hashCode ());
                ps.println ("  (zone (net 0) (net_name \"\") (layer " + layer + ") (tstamp " + tstamp + ") (hatch edge 0.508)");
                ps.println ("     (connect_pads (clearance 0.508))");
                ps.println ("     (min_thickness 0.254)");
                ps.println ("     (keepout (tracks not_allowed) (vias not_allowed) (copperpour not_allowed))");
                ps.println ("     (fill (arc_segments 16) (thermal_gap 0.508) (thermal_bridge_width 0.508))");
                ps.println ("     (polygon");
                ps.println ("       (pts");
                ps.println ("         (xy " + leftmm + " " + topmm + ")");
                ps.println ("         (xy " + ritemm + " " + topmm + ")");
                ps.println ("         (xy " + ritemm + " " + botmm + ")");
                ps.println ("         (xy " + leftmm + " " + botmm + ")");
                ps.println ("       )");
                ps.println ("     )");
                ps.println ("  )");
            }

            leftmm = String.format ("%4.2f", (moduleleftx +  5.0) * 2.54);
            ritemm = String.format ("%4.2f", (moduleleftx + 18.5) * 2.54);
            topmm  = String.format ("%4.2f", (moduletopy  +  3.5) * 2.54);
            botmm  = String.format ("%4.2f", (moduletopy  + 21.5) * 2.54);
            ps.println ("  (gr_line (start " + leftmm + " " + topmm + ") (end " + ritemm + " " + topmm + ") (angle 90) (layer Edge.Cuts) (width 0.1))");
            ps.println ("  (gr_line (start " + ritemm + " " + topmm + ") (end " + ritemm + " " + botmm + ") (angle 90) (layer Edge.Cuts) (width 0.1))");
            ps.println ("  (gr_line (start " + ritemm + " " + botmm + ") (end " + leftmm + " " + botmm + ") (angle 90) (layer Edge.Cuts) (width 0.1))");
            ps.println ("  (gr_line (start " + leftmm + " " + botmm + ") (end " + leftmm + " " + topmm + ") (angle 90) (layer Edge.Cuts) (width 0.1))");
            ps.println ("  (gr_line (start " + leftmm + " " + topmm + ") (end " + ritemm + " " + topmm + ") (angle 90) (layer F.SilkS) (width 0.2))");
            ps.println ("  (gr_line (start " + ritemm + " " + topmm + ") (end " + ritemm + " " + botmm + ") (angle 90) (layer F.SilkS) (width 0.2))");
            ps.println ("  (gr_line (start " + ritemm + " " + botmm + ") (end " + leftmm + " " + botmm + ") (angle 90) (layer F.SilkS) (width 0.2))");
            ps.println ("  (gr_line (start " + leftmm + " " + botmm + ") (end " + leftmm + " " + topmm + ") (angle 90) (layer F.SilkS) (width 0.2))");

            String midxmm = String.format ("%4.2f", (moduleleftx + 23.5/2) * 2.54);
            String midymm = String.format ("%4.2f", (moduletopy  + 25.0/2) * 2.54);
            ps.println ("  (gr_text \"CUT-OUT\" (at " + midxmm + " " + midymm + ") (layer F.SilkS)");
            ps.println ("    (effects (font (size 2.5 2.5) (thickness 0.3)))");
            ps.println ("  )");
        }
    }

    /**
     * BiDirectional data line
     *                                                                        (VCC)
                                           (V33)                                |
                                             |                                  _
                                             _                                rocol
                                           rcoll                                _
                                             _                                  |--------(mqnet)
                                             |                                 /
                                          (_pinet)----[robas]----(obasnet)----|  otran
                                             |                       |         \
                                            /                        _          |
        (mdnet)----[inres]----(basenet)----|  trans                roshn        |
                                  |         \                        _          |
                                  _          |                       |          |
                                zener     (skynet)              (_qenanet)
                                           shoky
                                  |          _
                                (GND)        |
                                        (_denanet)
     */
    private class PiBiCell extends Placeable implements PreDrawable {
        public Network _pinet;

        private Comp.ByCap bycap;
        private Comp.ByCap obycp;

        private Comp.Resis inres;
        private Comp.Diode zener;
        private Comp.Diode shoky;
        private Comp.Resis rcoll;
        private Comp.Resis robas;
        private Comp.Resis rocol;
        private Comp.Resis roshn;

        private Comp.Trans otran;
        private Comp.Trans trans;

        private double leftx;
        private double topy;

        private Network _denanet;
        private Network _qenanet;
        private Network skynet;
        private Network mdcpunet;
        private Network mqcpunet;
        private Network obasnet;

        private String name;

        public PiBiCell (GenCtx genctx, String name, Network _denanet, Network _qenanet, Network mdcpunet, Network mqcpunet)
        {
            this.name     = name;
            this._denanet = _denanet;
            this._qenanet = _qenanet;
            this.mdcpunet = mdcpunet;
            this.mqcpunet = mqcpunet;

            bycap = new Comp.ByCap (genctx, null, "BC1." + name);
            obycp = new Comp.ByCap (genctx, null, "BC2." + name);

            inres = new Comp.Resis (genctx, null, "R0." + name, "10K",    false, true);
            zener = new Comp.Diode (genctx, null, "D1." + name, "1N5239", true,  true); // 9.1V, anything over 5V is good
            shoky = new Comp.Diode (genctx, null, "D2." + name, "SD103B", true,  true); // 30V schottky
            rcoll = new Comp.Resis (genctx, null, "R2." + name, "1.8K",   false, true);
            robas = new Comp.Resis (genctx, null, "R3." + name, "2.2K",   false, true);
            rocol = new Comp.Resis (genctx, null, "R4." + name, "2.2K",   false, true);
            roshn = new Comp.Resis (genctx, null, "R5." + name, "1.0K",   false, true);

            otran = new Comp.Trans (genctx, null, "Q2." + name, "2N3904");
            trans = new Comp.Trans (genctx, null, "Q1." + name, "2N7000");

            _pinet  = new Network (genctx, "_" + name);
            obasnet = new Network (genctx, "BO." + name);
            Network basenet = new Network (genctx, "BI." + name);
            Network skynet  = new Network (genctx, "EI." + name);
            Network gndnet  = genctx.nets.get ("GND");

            mdcpunet.addConn (inres, Comp.Resis.PIN_C);
            gndnet.addConn   (zener, Comp.Diode.PIN_A);

            _denanet.addConn (trans, Comp.Trans.PIN_E);
            _qenanet.preWire (roshn, Comp.Resis.PIN_A, otran, Comp.Trans.PIN_E);
            vccnet.addConn   (rocol, Comp.Resis.PIN_C);

            basenet.preWire  (inres, Comp.Resis.PIN_A, zener, Comp.Diode.PIN_C);
            basenet.preWire  (inres, Comp.Resis.PIN_A, trans, Comp.Trans.PIN_B);

            skynet.preWire   (trans, Comp.Trans.PIN_C, shoky, Comp.Diode.PIN_C);

            obasnet.addConn  (robas, Comp.Resis.PIN_A);
            obasnet.addConn  (roshn, Comp.Resis.PIN_C);
            obasnet.preWire  (robas, Comp.Resis.PIN_A, otran, Comp.Trans.PIN_B);

            mqcpunet.preWire (otran, Comp.Trans.PIN_C, rocol, Comp.Resis.PIN_A);

            _pinet.addConn (rcoll, Comp.Resis.PIN_A);
            _pinet.addConn (robas, Comp.Resis.PIN_C);
            _pinet.addConn (shoky, Comp.Diode.PIN_A);

            v33net.preWire (rcoll, Comp.Resis.PIN_C, bycap, Comp.ByCap.PIN_Y);

            gndnet.addConn (bycap, Comp.ByCap.PIN_Z);
            vccnet.addConn (obycp, Comp.ByCap.PIN_Y);
            gndnet.addConn (obycp, Comp.ByCap.PIN_Z);

            genctx.addPlaceable (this);
            genctx.predrawables.add (this);
        }

        @Override  // Placeable
        public String getName () { return name; }

        @Override  // Placeable
        public void flipIt () { }

        @Override  // Placeable
        public int getHeight () { return 6; }

        @Override  // Placeable
        public int getWidth  () { return 16; }

        @Override  // Placeable
        public double getPosX () { return zener.getPosX (); }

        @Override  // Placeable
        public double getPosY () { return zener.getPosY (); }

        @Override  // Placeable
        public void setPosXY (double leftx, double topy)
        {
            this.leftx = leftx;
            this.topy  = topy;

            shoky.setPosXY (leftx +  0.0, topy + 2.0);
            inres.setPosXY (leftx +  0.0, topy + 3.0);
            zener.setPosXY (leftx +  0.0, topy + 4.0);

            trans.setPosXY (leftx +  4.0, topy + 2.0);
            bycap.setPosXY (leftx +  4.0, topy + 2.0);

            rcoll.setPosXY (leftx +  8.0, topy + 2.0);
            robas.setPosXY (leftx +  8.0, topy + 3.0);
            roshn.setPosXY (leftx +  8.0, topy + 4.0);

            rocol.setPosXY (leftx + 11.0, topy + 0.0);
            otran.setPosXY (leftx + 12.0, topy + 2.0);
            obycp.setPosXY (leftx + 12.0, topy + 2.0);
        }

        @Override  // Placeable
        public Network[] getExtNets ()
        {
            return new Network[] { _pinet, _denanet, _qenanet, mdcpunet, mqcpunet };
        }

        @Override  // PreDrawable
        public void preDraw (PrintStream ps)
        {
            _pinet.putseg  (ps, leftx +  1.0, topy + 3.0, leftx +  1.5, topy + 3.5, "F.Cu");
            _pinet.putseg  (ps, leftx +  1.5, topy + 3.5, leftx +  8.5, topy + 3.5, "F.Cu");
            _pinet.putseg  (ps, leftx +  8.5, topy + 3.5, leftx +  9.0, topy + 4.0, "F.Cu");
            _pinet.putseg  (ps, leftx +  9.0, topy + 4.0, leftx +  9.5, topy + 3.5, "F.Cu");
            _pinet.putseg  (ps, leftx +  9.5, topy + 3.5, leftx + 10.5, topy + 3.5, "F.Cu");
            _pinet.putseg  (ps, leftx + 10.5, topy + 3.5, leftx + 11.0, topy + 3.0, "F.Cu");

            obasnet.putseg (ps, leftx +  9.0, topy + 5.0, leftx +  9.5, topy + 4.5, "F.Cu");
            obasnet.putseg (ps, leftx +  9.5, topy + 4.5, leftx + 10.5, topy + 4.5, "F.Cu");
            obasnet.putseg (ps, leftx + 10.5, topy + 4.5, leftx + 11.0, topy + 4.0, "F.Cu");
        }
    }
}
