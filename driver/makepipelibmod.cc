//    Copyright (C) Mike Rieker, Beverly, MA USA
//    www.outerworldapps.com
//
//    This program is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; version 2 of the License.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    EXPECT it to FAIL when someone's HeALTh or PROpeRTy is at RISk.
//
//    You should have received a copy of the GNU General Public License
//    along with this program; if not, write to the Free Software
//    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//    http://www.gnu.org/licenses/gpl-2.0.html

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "makepipelibmod.h"
#include "miscdefs.h"
#include "pindefs.h"

struct Module {
    char const *name;
    uint32_t ins[4];
    uint32_t outs[4];
};

#define NMODULES 6
static Module const modules[NMODULES] = {
    { "acl", acl_ains, acl_bins, acl_cins, acl_dins, acl_aouts, acl_bouts, acl_couts, acl_douts },
    { "alu", alu_ains, alu_bins, alu_cins, alu_dins, alu_aouts, alu_bouts, alu_couts, alu_douts },
    { "ma",  ma_ains,  ma_bins,  ma_cins,  ma_dins,  ma_aouts,  ma_bouts,  ma_couts,  ma_douts  },
    { "pc",  pc_ains,  pc_bins,  pc_cins,  pc_dins,  pc_aouts,  pc_bouts,  pc_couts,  pc_douts  },
    { "rpi", rpi_ains, rpi_bins, rpi_cins, rpi_dins, rpi_aouts, rpi_bouts, rpi_couts, rpi_douts },
    { "seq", seq_ains, seq_bins, seq_cins, seq_dins, seq_aouts, seq_bouts, seq_couts, seq_douts } };

// create module file ../modules/testpads_<pipelibmod>.mod if doesn't already exist
// then re-create ../modules/whole.mod to include it
//  input:
//   pipelibmod = all selected module names concatted in 'modules' array order (alphabetized)
//  output:
//   ../modules/testpads_<pipelibmod>.mod exists
//   ../modules/whole.mod updated to include it (used by PipeLib)
char const *makepipelibmod (char const *pipelibmod)
{
    // whole.mod contains proc as is
    if (strcmp (pipelibmod, "proc") == 0) return pipelibmod;

    // whole.mod contains rpi as rpi_testpads
    // rpi_testpads has the gpio pins in the correct place for netgen to find
    if (strcmp (pipelibmod, "rpi") == 0) return "rpi_testpads";

    // assume if testpads_<pipelibmod>.mod exists, whole.mod contains it
    char exedir[4000];
    getexedir (exedir, sizeof exedir);
    char modpath[strlen(exedir)+30+strlen(pipelibmod)];
    sprintf (modpath, "%s../modules/testpads_%s.mod", exedir, pipelibmod);
    if (access (modpath, R_OK) >= 0) return pipelibmod;

    // assume all pins are inputs except 01 are grounds
    char masks[4][33];
    strcpy (masks[0], "giiiiiiiiiiiiiiiiiiiiiiiiiiiiiii");
    strcpy (masks[1], "giiiiiiiiiiiiiiiiiiiiiiiiiiiiiii");
    strcpy (masks[2], "giiiiiiiiiiiiiiiiiiiiiiiiiiiiiii");
    strcpy (masks[3], "giiiiiiiiiiiiiiiiiiiiiiiiiiiiiii");

    // step through the selected per-board modules
    // pins marked as output by any module are marked as output
    bool hasrpi = false;
    char const *selected = pipelibmod;
    uint32_t selmask = 0;
    for (int k = 0; k < NMODULES; k ++) {
        Module const *mod = &modules[k];
        int namelen = strlen (mod->name);
        if (memcmp (mod->name, selected, namelen) == 0) {
            if (strcmp (mod->name, "rpi") == 0) hasrpi = true;
            selected += namelen;
            selmask |= 1U << k;
            for (int j = 0; j < 4; j ++) {
                uint32_t outs = mod->outs[j];
                for (int i = 0; i < 32; i ++) {
                    if (outs & 1) masks[j][i] = 'o';
                    outs >>= 1;
                }
            }
        }
    }

    // should have processed the whole selection list
    if (*selected != 0) {
        fprintf (stderr, "makepipelibmod: bad module list %s at %s\n", pipelibmod, selected);
        ABORT ();
    }

    // whole.mod always contains the individual modules
    if ((selmask & - selmask) == selmask) return pipelibmod;

    // write out composite module file
    //  module <pipelibmod> ()
    //  {
    //  #define {abcd}mask <composite-32-character-strings>
    //  #include "cons.inc"
    //  ... instantiate per-board modules
    //  }
    FILE *modfile = fopen (modpath, "w");
    if (modfile == NULL) {
        fprintf (stderr, "makepipelibmod: error creating %s: %m\n", modpath);
        ABORT ();
    }
    fprintf (modfile, "// auto-generated by makepipelibmod.cc\n");
    if (hasrpi) {
        fprintf (modfile, "module %s\n", pipelibmod);
        fprintf (modfile, "    (in CLOK2, in INTRQ, in IOSKP, in MQ[11:00], in MQL, in RESET, in QENA, in DENA,\n");
        fprintf (modfile, "    out _DFRM, out _JUMP, out _INTAK, out IOINST, out _MDL, out _MD[11:00], out _MREAD, out _MWRITE)\n");
    } else {
        fprintf (modfile, "module %s ()\n", pipelibmod);
    }
    fprintf (modfile, "{\n");
    for (int i = 0; i < 4; i ++) {
        fprintf (modfile, "#define %cmask %s\n", 'a' + i, masks[i]);
    }
    fprintf (modfile, "#include \"cons.inc\"\n");

    for (int k = 0; k < NMODULES; k ++) {
        if (selmask & (1U << k)) {
            Module const *mod = &modules[k];                                        // get selected module
            if (strcmp (mod->name, "rpi") == 0) {
                fprintf (modfile, "\n"
                    "    clok2 = CLOK2;\n"
                    "    intrq = INTRQ;\n"
                    "    ioskp = IOSKP;\n"
                    "    mq    = MQ;\n"
                    "    mql   = MQL;\n"
                    "    reset = RESET;\n"
                    "\n"
                    "    _DFRM   = _dfrm;\n"
                    "    _JUMP   = _jump;\n"
                    "    _INTAK  = _intak;\n"
                    "    IOINST  = ioinst;\n"
                    "    _MDL    = _lnq;\n"
                    "    _MD     = _aluq;\n"
                    "    _MREAD  = _mread;\n"
                    "    _MWRITE = _mwrite;\n");
            } else {
                fprintf (modfile, "\n    %scirc: %scirc (", mod->name, mod->name);  // start instantiation of the module
                bool first = true;
                for (int j = 0; j < 4; j ++) {                                      // loop through a,b,c,d connectors
                    PinDefs const *defs = pindefss[j];                              // names of all pins on the connector
                    uint32_t pins = mod->ins[j] | mod->outs[j];                     // list of all pins accessed by module
                    for (int m = 0; defs[m].pinmask != 0; m ++) {                   // loop through all pins on the connector
                        if (pins & defs[m].pinmask) {                               // see if pin is used by module
                            char const *varname = defs[m].varname;                  // output pin name as a module parameter
                            char const *openbkt = strchr (varname, '[');
                            int n = 0;
                            if (openbkt == NULL) n = strlen (varname);
                            else if (strcmp (openbkt, "[11]") == 0) n = openbkt - varname;
                            if (n > 0) {
                                if (! first) fputc (',', modfile);
                                fprintf (modfile, "\n        %16.*s: %.*s", n, varname, n, varname);
                                first = false;
                            }
                        }
                    }
                }
                fprintf (modfile, ");\n");
            }
        }
    }

    fprintf (modfile, "}\n");
    if (ferror (modfile) || (fclose (modfile) < 0)) {
        fprintf (stderr, "makepipelibmod: error writing %s: %m\n", modpath);
        unlink (modpath);
        ABORT ();
    }

    // re-create ../modules/whole.mod to include composite module file just created
    char makecmd[strlen(exedir)+32];
    sprintf (makecmd, "cd %s../modules ; make whole.mod", exedir);
    int rc = system (makecmd);
    if (rc != 0) {
        fprintf (stderr, "makepipelibmod: error %d making whole.mod\n", rc);
        ABORT ();
    }

    return pipelibmod;
}
